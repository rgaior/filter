import utils
import math
import numpy as np
import constant
#import waveform

class Simulation:
    def __init__(self, snr = 0,
                 siglength = 0,
                 det = None):
        
        self.snr = snr
        self.det = det
        self.siglength = siglength
        
        self.powerenvelope = np.array([])
 
        self.time = np.array([])
        self.noise = np.array([])
        self.signal = np.array([])
        self.envelope = np.array([])
        self.wf = np.array([])
        
        #hardcoded
        self.tracelength = 10e-6 #s
        self.sampling = 5e9 #Hz
        self.sigtime = self.tracelength/4



    def producetime(self):
        self.time = np.arange(0,self.tracelength,1./self.sampling)
        
    #produce the signal in time vs amplitude [V]
    def producenoise(self):
        Pnoise = constant.kb*self.det.temp*self.det.bw 
        Vnoise = np.sqrt(constant.impedance*Pnoise)
        self.noise = utils.wf_normal(0,Vnoise,len(self.time))
        
    def setpowerenvelope(self, type):
        if type == 'gauss':
            powerenvelope =  utils.func_normedgauss(self.time,self.sigtime,self.siglenth)
        if type == 'file':
            # get the envelope (time vs power [W]) from a file
            timepower = utils.readsimfile(file)
            # first shift the signal i.e. add or remove some time
            timeofmax = timepower[0][np.argmax(timepower[1])]
            timepower[0] = timepower[0] - timeofmax + self.sigtime
            # then resample
            newamp = np.interp(self.time,timepower[0],timepower[1])
            # replace the negative value possibly coming from interpolation
            newamp[newamp < 0] = np.max(timepower[1])*1e-10
            powerenvelope = newamp
        # first shift the max to self.sigtime
        self.powerenvelope = powerenvelope

    #produce the signal in time vs amplitude [V]
    def producesignal(self):
        Pnoise = constant.kb*self.det.temp*self.det.bw 
        Vnoise = np.sqrt(constant.impedance*Pnoise)
        signal = utils.wf_normal(0,Vnoise,len(self.time))
        self.signal = np.sqrt(self.powerenvelope)*math.sqrt(self.snr)*signal
